From: Yeping Miao
Subject: ffmpeg hifi4 dsp support patch

Index: ffmpeg-3.4.5/libavcodec/amldec.c
===================================================================
--- ffmpeg-3.4.5-ori/libavcodec/amldec.c	1970-01-01 08:00:00.000000000 +0800
+++ ffmpeg-3.4.5/libavcodec/amldec.c	2019-08-05 16:10:32.462734049 +0800
@@ -0,0 +1,264 @@
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <assert.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <time.h>
+
+#include "libavutil/attributes.h"
+#include "libavutil/audio_fifo.h"
+#include "libavutil/channel_layout.h"
+#include "libavutil/opt.h"
+
+#include "libswresample/swresample.h"
+
+#include "mpegaudio.h"
+
+#include "avcodec.h"
+#include "get_bits.h"
+#include "internal.h"
+#include "mathops.h"
+
+#include "aml_dsp/rpc_client_aipc.h"
+#include "aml_dsp/rpc_client_mp3.h"
+#include "aml_dsp/rpc_client_shm.h"
+#include "aml_dsp/aipc_type.h"
+
+#include "amldec.h"
+
+typedef struct _tag_DecoderHandle {
+  enum AVCodecID  codec_id;
+  tAmlACodecConfig_Mp3DecExternal config;
+  void *dsp_codec;
+
+} AmlACodec_t;
+
+#define MAX_SHARE_INPUT_MEMORY_SIZE kInputBufferSize
+#define MAX_SHARE_OUTPUT_MEMORY_SIZE kOutputBufferSize
+
+// #define ALLOCATE_SHARE_MEMORY
+#ifdef ALLOCATE_SHARE_MEMORY
+  tAcodecShmHdl hShmInput =0;
+  tAcodecShmHdl hShmOutput = 0;
+  uint8_t *inputBuf = 0;
+  int16_t *outputBuf = 0;
+  void* inputphy = 0;
+  void* outputphy = 0;
+#endif
+
+
+static void* AmlACodecInit(enum AVCodecID id) {
+  AmlACodec_t *pCodec = NULL;
+
+  // mallock AmlACodec_t
+  pCodec = (AmlACodec_t*)calloc(1, sizeof(AmlACodec_t));
+  if (NULL == pCodec) {
+    printf("Cannot malloc memory size = %d\n", sizeof(AmlACodec_t));
+    return NULL;
+  }
+  switch (id){
+  case AV_CODEC_ID_MP3:
+    pCodec->config.equalizerType = flat;
+    pCodec->config.crcEnabled = false;
+    pCodec->dsp_codec = AmlACodecInit_Mp3Dec(&(pCodec->config));
+    if (NULL == pCodec->dsp_codec) {
+      printf("tAmlACodecConfig_Mp3DecExternal failed\n");
+      free(pCodec);
+      pCodec = NULL;
+    } else {
+      pCodec->codec_id = id;
+    }
+    break;
+  default:
+    printf("Cannot support id %d\n", id);
+    break;
+  }
+
+  return (void*)pCodec;
+}
+
+static av_cold void AmlACodecDeInit(void *codec) {
+  AmlACodec_t *pCodec = (AmlACodec_t*)codec;
+  if (NULL == pCodec) return;
+  switch (pCodec->codec_id){
+  case AV_CODEC_ID_MP3:
+    AmlACodecDeInit_Mp3Dec(pCodec->dsp_codec);
+
+    break;
+  default:
+    printf("It should not come to here id %d\n", pCodec->codec_id);
+    break;
+  }
+
+  free(pCodec);
+  return;
+}
+
+
+static void *aml_dsp_codec = NULL;
+void aml_decode_flush(AVCodecContext *avctx) {
+}
+
+void aml_decode_close(AVCodecContext *avctx)
+{
+    //AmlContext *c = avctx->priv_data;
+#ifdef ALLOCATE_SHARE_MEMORY
+    printf("####AMLOGIC Hifi##### free related data buffer\n");
+    if (0 != hShmInput) {
+      Aml_ACodecMemory_Free((tAcodecShmHdl)hShmInput);
+      hShmInput = 0;
+    }
+    if (0 != hShmOutput) {
+		  Aml_ACodecMemory_Free((tAcodecShmHdl)hShmOutput);
+      hShmOutput = 0;
+    }
+#endif
+
+    AmlACodecDeInit(aml_dsp_codec);
+    aml_dsp_codec = NULL;
+}
+
+
+int aml_decode_open(AVCodecContext *avctx)
+{
+    if (aml_dsp_codec) return 0;
+    aml_dsp_codec = AmlACodecInit(avctx->codec_id);
+    printf("####AMLOGIC Hifi#####  decode init\n");
+    if (NULL == aml_dsp_codec) return -1;
+#ifdef ALLOCATE_SHARE_MEMORY
+      // allocate the sharememory
+    hShmInput = Aml_ACodecMemory_Allocate(MAX_SHARE_INPUT_MEMORY_SIZE);
+		inputBuf = (uint8_t*)Aml_ACodecMemory_GetVirtAddr(hShmInput);
+		inputphy = Aml_ACodecMemory_GetPhyAddr(hShmInput);
+
+		// Allocate output buffer.
+		hShmOutput = Aml_ACodecMemory_Allocate(MAX_SHARE_OUTPUT_MEMORY_SIZE);
+		outputBuf = (int16_t*)Aml_ACodecMemory_GetVirtAddr(hShmOutput);
+		outputphy = Aml_ACodecMemory_GetPhyAddr(hShmOutput);
+#endif
+
+    return 0;
+}
+
+#ifdef ALLOCATE_SHARE_MEMORY
+int aml_decode_frame(AVCodecContext *avctx, void *data,
+    const uint8_t *buf, int buf_size)
+{
+  AmlACodec_t *pCodec = (AmlACodec_t*)aml_dsp_codec;
+   struct timespec begin_time, end_time;
+  int  ret;
+  AVFrame *frame = data;
+  clock_gettime(CLOCK_MONOTONIC, &begin_time);
+  printf("####AMLOGIC Hifi#####  decode frame %d\n", buf_size);
+  frame->nb_samples = MPA_FRAME_SIZE *10;
+  if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
+    return ret;
+ //  printf("####AMLOGIC Hifi##### allocate frame ok %d, data:%lx\n",
+ //     MPA_FRAME_SIZE, (unsigned long)frame->data[0]);
+
+  memcpy(inputBuf, buf, buf_size);
+  // Set the input config.
+  pCodec->config.inputBufferCurrentLength = buf_size;
+  pCodec->config.inputBufferMaxLength = 0;
+  pCodec->config.inputBufferUsedLength = 0;
+  pCodec->config.pInputBuffer = (uint8_t*)inputphy;
+	pCodec->config.pOutputBuffer = (int16_t*)outputphy;
+  pCodec->config.outputFrameSize = MAX_SHARE_OUTPUT_MEMORY_SIZE;
+  //printf("config.outputFrameSize:%d\n", config.outputFrameSize);
+
+  Aml_ACodecMemory_Clean(inputphy, buf_size);
+	ret = AmlACodecExec_UserAllocIoShm_Mp3Dec(pCodec->dsp_codec,
+      &(pCodec->config));
+	Aml_ACodecMemory_Inv(outputphy,
+      pCodec->config.outputFrameSize*sizeof(int16_t));
+  // printf("####AMLOGIC Hifi#####  finished ret = %d decode frame %d\n",
+  //     ret, pCodec->config.outputFrameSize);
+  if (ret != NO_DECODING_ERROR) {
+    av_frame_unref(frame);
+    return -1;
+  }
+#if 0
+  {
+    static FILE *saved_fd = NULL;
+    static int save_length = 0;
+    if (saved_fd == NULL && save_length == 0) {
+      saved_fd = fopen("/tmp/save.wav", "w+");
+    }
+    if (saved_fd) {
+        fwrite(outputBuf, 1, pCodec->config.outputFrameSize*sizeof(int16_t), saved_fd);
+        save_length += pCodec->config.outputFrameSize*sizeof(int16_t);
+        if (save_length >= 1024*1024) {
+          fclose(saved_fd);
+          saved_fd = NULL;
+        }
+    }
+
+  }
+#endif
+  memcpy(frame->data[0], outputBuf,
+      pCodec->config.outputFrameSize*sizeof(int16_t));
+// printf("####AMLOGIC Hifi#####  done \n");
+  frame->nb_samples = pCodec->config.outputFrameSize/pCodec->config.num_channels;
+  avctx->frame_size = frame->nb_samples;
+
+  avctx->sample_rate = pCodec->config.samplingRate;
+  avctx->sample_fmt = AV_SAMPLE_FMT_S16;
+  frame->format = AV_SAMPLE_FMT_S16;
+  avctx->channels = pCodec->config.num_channels;
+  avctx->bit_rate = pCodec->config.bitRate;
+  frame->sample_rate = pCodec->config.samplingRate;
+  frame->channels = pCodec->config.num_channels;
+  printf("####AMLOGIC Hifi#####  done, output frame = %d , channels = %d, nb_samples:%d\n",
+      pCodec->config.outputFrameSize, pCodec->config.num_channels, frame->nb_samples);
+#if 0
+  clock_gettime(CLOCK_MONOTONIC, &end_time);
+  printf("####AMLOGIC Hifi#####  copy to frame %d, samplerate = %d, interval = %d\n",
+      pCodec->config.outputFrameSize*sizeof(int16_t), pCodec->config.samplingRate,
+      end_time.tv_nsec - begin_time.tv_nsec);
+#endif
+
+  return 0;
+}
+#else
+int aml_decode_frame(AVCodecContext *avctx, void *data,
+    const uint8_t *buf, int buf_size)
+{
+  AmlACodec_t *pCodec = (AmlACodec_t*)aml_dsp_codec;
+  int  ret;
+  AVFrame *frame = data;
+  frame->nb_samples = MAX_SHARE_OUTPUT_MEMORY_SIZE;
+  if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
+    return ret;
+  // Set the input config.
+  pCodec->config.inputBufferCurrentLength = buf_size;
+  pCodec->config.inputBufferMaxLength = 0;
+  pCodec->config.inputBufferUsedLength = 0;
+  pCodec->config.pInputBuffer = (uint8_t*)buf;
+  pCodec->config.pOutputBuffer = (int16_t*)frame->data[0];
+  pCodec->config.outputFrameSize = MPA_FRAME_SIZE*10;
+  ret = AmlACodecExec_Mp3Dec(pCodec->dsp_codec, &(pCodec->config));
+  if (ret != NO_DECODING_ERROR) {
+    av_frame_unref(frame);
+    return -1;
+  }
+
+  // Fill the frame parameter
+  frame->nb_samples =
+    pCodec->config.outputFrameSize/pCodec->config.num_channels;
+  frame->format = AV_SAMPLE_FMT_S16;
+  frame->sample_rate = pCodec->config.samplingRate;
+  frame->channels = pCodec->config.num_channels;
+
+  // Fill the AVCodecContext parameters
+  avctx->frame_size = frame->nb_samples;
+  avctx->sample_rate = pCodec->config.samplingRate;
+  avctx->sample_fmt = AV_SAMPLE_FMT_S16;
+  avctx->channels = pCodec->config.num_channels;
+  avctx->bit_rate = pCodec->config.bitRate;
+
+  return 0;
+}
+#endif
+
+

